---
subcategory: "Batch"
layout: "aws"
page_title: "AWS: aws_batch_compute_environment"
description: |-
  Creates a AWS Batch compute environment.
---

# Resource: aws_batch_compute_environment

Creates a AWS Batch compute environment. Compute environments contain the Amazon ECS container instances that are used to run containerized batch jobs.

For information about AWS Batch, see [What is AWS Batch?][1] .
For information about compute environment, see [Compute Environments][2] .

~> **Note:** To prevent a race condition during environment deletion, make sure to set `depends_on` to the related `aws_iam_role_policy_attachment`;
otherwise, the policy may be destroyed too soon and the compute environment will then get stuck in the `DELETING` state, see [Troubleshooting AWS Batch][3] .

## Example Usage

### EC2 Type

```python
import constructs as constructs
import cdktf as cdktf
# Provider bindings are generated by running cdktf get.
# See https://cdk.tf/provider-generation for more details.
import ...gen.providers.aws as aws
class MyConvertedCode(cdktf.TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        aws_security_group_sample = aws.security_group.SecurityGroup(self, "sample",
            egress=[SecurityGroupEgress(
                cidr_blocks=["0.0.0.0/0"],
                from_port=0,
                protocol="-1",
                to_port=0
            )
            ],
            name="aws_batch_compute_environment_security_group"
        )
        aws_vpc_sample = aws.vpc.Vpc(self, "sample_1",
            cidr_block="10.1.0.0/16"
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_vpc_sample.override_logical_id("sample")
        data_aws_iam_policy_document_batch_assume_role =
        aws.data_aws_iam_policy_document.DataAwsIamPolicyDocument(self, "batch_assume_role",
            statement=[DataAwsIamPolicyDocumentStatement(
                actions=["sts:AssumeRole"],
                effect="Allow",
                principals=[DataAwsIamPolicyDocumentStatementPrincipals(
                    identifiers=["batch.amazonaws.com"],
                    type="Service"
                )
                ]
            )
            ]
        )
        data_aws_iam_policy_document_ec2_assume_role =
        aws.data_aws_iam_policy_document.DataAwsIamPolicyDocument(self, "ec2_assume_role",
            statement=[DataAwsIamPolicyDocumentStatement(
                actions=["sts:AssumeRole"],
                effect="Allow",
                principals=[DataAwsIamPolicyDocumentStatementPrincipals(
                    identifiers=["ec2.amazonaws.com"],
                    type="Service"
                )
                ]
            )
            ]
        )
        aws_iam_role_aws_batch_service_role = aws.iam_role.IamRole(self, "aws_batch_service_role",
            assume_role_policy=cdktf.Token.as_string(data_aws_iam_policy_document_batch_assume_role.json),
            name="aws_batch_service_role"
        )
        aws_iam_role_ecs_instance_role = aws.iam_role.IamRole(self, "ecs_instance_role",
            assume_role_policy=cdktf.Token.as_string(data_aws_iam_policy_document_ec2_assume_role.json),
            name="ecs_instance_role"
        )
        aws_iam_role_policy_attachment_aws_batch_service_role =
        aws.iam_role_policy_attachment.IamRolePolicyAttachment(self, "aws_batch_service_role_6",
            policy_arn="arn:aws:iam::aws:policy/service-role/AWSBatchServiceRole",
            role=cdktf.Token.as_string(aws_iam_role_aws_batch_service_role.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_iam_role_policy_attachment_aws_batch_service_role.override_logical_id("aws_batch_service_role")
        aws_iam_role_policy_attachment_ecs_instance_role =
        aws.iam_role_policy_attachment.IamRolePolicyAttachment(self, "ecs_instance_role_7",
            policy_arn="arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role",
            role=cdktf.Token.as_string(aws_iam_role_ecs_instance_role.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_iam_role_policy_attachment_ecs_instance_role.override_logical_id("ecs_instance_role")
        aws_subnet_sample = aws.subnet.Subnet(self, "sample_8",
            cidr_block="10.1.1.0/24",
            vpc_id=cdktf.Token.as_string(aws_vpc_sample.id)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_subnet_sample.override_logical_id("sample")
        aws_iam_instance_profile_ecs_instance_role =
        aws.iam_instance_profile.IamInstanceProfile(self, "ecs_instance_role_9",
            name="ecs_instance_role",
            role=cdktf.Token.as_string(aws_iam_role_ecs_instance_role.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_iam_instance_profile_ecs_instance_role.override_logical_id("ecs_instance_role")
        aws_batch_compute_environment_sample =
        aws.batch_compute_environment.BatchComputeEnvironment(self, "sample_10",
            compute_environment_name="sample",
            compute_resources=BatchComputeEnvironmentComputeResources(
                instance_role=cdktf.Token.as_string(aws_iam_instance_profile_ecs_instance_role.arn),
                instance_type=["c4.large"],
                max_vcpus=16,
                min_vcpus=0,
                security_group_ids=[cdktf.Token.as_string(aws_security_group_sample.id)],
                subnets=[cdktf.Token.as_string(aws_subnet_sample.id)],
                type="EC2"
            ),
            depends_on=[aws_iam_role_policy_attachment_aws_batch_service_role],
            service_role=cdktf.Token.as_string(aws_iam_role_aws_batch_service_role.arn),
            type="MANAGED"
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        aws_batch_compute_environment_sample.override_logical_id("sample")
```

### Fargate Type

```hcl
resource "aws_batch_compute_environment" "sample" {
  compute_environment_name = "sample"

  compute_resources {
    max_vcpus = 16

    security_group_ids = [
      aws_security_group.sample.id
    ]

    subnets = [
      aws_subnet.sample.id
    ]

    type = "FARGATE"
  }

  service_role = aws_iam_role.aws_batch_service_role.arn
  type         = "MANAGED"
  depends_on   = [aws_iam_role_policy_attachment.aws_batch_service_role]
}
```

## Argument Reference

* `compute_environment_name` - (Optional, Forces new resource) The name for your compute environment. Up to 128 letters (uppercase and lowercase), numbers, and underscores are allowed. If omitted, Terraform will assign a random, unique name.
* `compute_environment_name_prefix` - (Optional, Forces new resource) Creates a unique compute environment name beginning with the specified prefix. Conflicts with `compute_environment_name`.
* `compute_resources` - (Optional) Details of the compute resources managed by the compute environment. This parameter is required for managed compute environments. See details below.
* `eks_configuration` - (Optional) Details for the Amazon EKS cluster that supports the compute environment. See details below.
* `service_role` - (Required) The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch to make calls to other AWS services on your behalf.
* `state` - (Optional) The state of the compute environment. If the state is `ENABLED`, then the compute environment accepts jobs from a queue and can scale out automatically based on queues. Valid items are `ENABLED` or `DISABLED`. Defaults to `ENABLED`.
* `tags` - (Optional) Key-value map of resource tags. If configured with a provider [`default_tags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block) present, tags with matching keys will overwrite those defined at the provider-level.
* `type` - (Required) The type of the compute environment. Valid items are `MANAGED` or `UNMANAGED`.

### compute_resources

* `allocation_strategy` - (Optional) The allocation strategy to use for the compute resource in case not enough instances of the best fitting instance type can be allocated. Valid items are `BEST_FIT_PROGRESSIVE`, `SPOT_CAPACITY_OPTIMIZED` or `BEST_FIT`. Defaults to `BEST_FIT`. See [AWS docs](https://docs.aws.amazon.com/batch/latest/userguide/allocation-strategies.html) for details. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `bid_percentage` - (Optional) Integer of maximum percentage that a Spot Instance price can be when compared with the On-Demand price for that instance type before instances are launched. For example, if your bid percentage is 20% (`20`), then the Spot price must be below 20% of the current On-Demand price for that EC2 instance. If you leave this field empty, the default value is 100% of the On-Demand price. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `desired_vcpus` - (Optional) The desired number of EC2 vCPUS in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `ec2_configuration` - (Optional) Provides information used to select Amazon Machine Images (AMIs) for EC2 instances in the compute environment. If Ec2Configuration isn't specified, the default is ECS_AL2. This parameter isn't applicable to jobs that are running on Fargate resources, and shouldn't be specified.
* `ec2_key_pair` - (Optional) The EC2 key pair that is used for instances launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `image_id` - (Optional) The Amazon Machine Image (AMI) ID used for instances launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified. (Deprecated, use [`ec2_configuration`](#ec2_configuration) `image_id_override` instead)
* `instance_role` - (Optional) The Amazon ECS instance role applied to Amazon EC2 instances in a compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `instance_type` - (Optional) A list of instance types that may be launched. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `launch_template` - (Optional) The launch template to use for your compute resources. See details below. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `max_vcpus` - (Required) The maximum number of EC2 vCPUs that an environment can reach.
* `min_vcpus` - (Optional) The minimum number of EC2 vCPUs that an environment should maintain. For `EC2` or `SPOT` compute environments, if the parameter is not explicitly defined, a `0` default value will be set. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `security_group_ids` - (Optional) A list of EC2 security group that are associated with instances launched in the compute environment. This parameter is required for Fargate compute environments.
* `spot_iam_fleet_role` - (Optional) The Amazon Resource Name (ARN) of the Amazon EC2 Spot Fleet IAM role applied to a SPOT compute environment. This parameter is required for SPOT compute environments. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `subnets` - (Required) A list of VPC subnets into which the compute resources are launched.
* `tags` - (Optional) Key-value pair tags to be applied to resources that are launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
* `type` - (Required) The type of compute environment. Valid items are `EC2`, `SPOT`, `FARGATE` or `FARGATE_SPOT`.

### ec2_configuration

`ec2_configuration` supports the following:

* `image_id_override` - (Optional) The AMI ID used for instances launched in the compute environment that match the image type. This setting overrides the `image_id` argument in the [`compute_resources`](#compute_resources) block.
* `image_type` - (Optional) The image type to match with the instance type to select an AMI. If the `image_id_override` parameter isn't specified, then a recent [Amazon ECS-optimized Amazon Linux 2 AMI](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html#al2ami) (`ECS_AL2`) is used.

### launch_template

`launch_template` supports the following:

* `launch_template_id` - (Optional) ID of the launch template. You must specify either the launch template ID or launch template name in the request, but not both.
* `launch_template_name` - (Optional) Name of the launch template.
* `version` - (Optional) The version number of the launch template. Default: The default version of the launch template.

### eks_configuration

`eks_configuration` supports the following:

* `eks_cluster_arn` - (Required) The Amazon Resource Name (ARN) of the Amazon EKS cluster.
* `kubernetes_namespace` - (Required) The namespace of the Amazon EKS cluster. AWS Batch manages pods in this namespace.

## Attributes Reference

In addition to all arguments above, the following attributes are exported:

* `arn` - The Amazon Resource Name (ARN) of the compute environment.
* `ecs_cluster_arn` - The Amazon Resource Name (ARN) of the underlying Amazon ECS cluster used by the compute environment.
* `status` - The current status of the compute environment (for example, CREATING or VALID).
* `status_reason` - A short, human-readable string to provide additional details about the current status of the compute environment.
* `tags_all` - A map of tags assigned to the resource, including those inherited from the provider [`default_tags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block).

## Import

AWS Batch compute can be imported using the `compute_environment_name`, e.g.,

```
$ terraform import aws_batch_compute_environment.sample sample
```

[1]: http://docs.aws.amazon.com/batch/latest/userguide/what-is-batch.html
[2]: http://docs.aws.amazon.com/batch/latest/userguide/compute_environments.html
[3]: http://docs.aws.amazon.com/batch/latest/userguide/troubleshooting.html

<!-- cache-key: cdktf-0.17.0-pre.15 input-ec0488d3fc9d169e01c5c247e3998ea9a44f81ecd25a21a293f777c13003c6a3 -->